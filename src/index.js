/**
 * @file index.js
 * 
  * The Android Debug Bridge is used for communication.
 * 
 * ActivityManager documentation
 * https://developer.android.com/studio/command-line/adb#am
 * 
 * Firefox in private mode:
 * https://stackoverflow.com/questions/55421838/firefox-private-mode-on-android-start-via-adb-commandline-parameters
 * 
 * Chrome in private mode (does not work):
 * https://stackoverflow.com/questions/35198003/how-to-open-chrome-in-incognito-tab
 * 
 * Screenshot issues with Firefox:
 * https://stackoverflow.com/questions/55412931/testcafe-screenshot-browser-provider-for-android-crop-js-unable-to-locate-the/
 * https://github.com/DevExpress/testcafe/issues/2918
 * 
 */
import { promisify } from 'util';
import { exec as _exec } from 'child_process';
import { copyFile as _copyFile, unlink as _unlink } from 'fs';

import * as debug from './debug';

const exec = promisify(_exec);
const copyFile = promisify(_copyFile);
const unlink = promisify(_unlink);

export default {
    
    /** Multiple browsers support
     * 
     * testcafe-browser-provider-android does support multiple browsers.
     */
    isMultiBrowser: true,

    /** Defines info and commands for a specifc browsers.
     * 
     * @typedef {Object} BrowserDefinition
     * @property {string} name Short name of the browser i.e. `chrome`
     * @property {string} packageName i.e. `com.android.chrome`
     * @property {string} startCommand the substring `{ifURL}` is replaced with `-d http://some.url.tld/` if any url is given to openBrowser.
     * @property {boolean} doClear should `pm clear` be called for this browser?
     * @property {string[]} resetWelcomeShellCommands commands to be sent in order to remove welcome messages from the browser
     * 
    */
    
    /** @type {Object<string, BrowserDefinition>} */
    _browserDefinitions: {
        chrome: {
            name:                      'chrome',
            packageName:               'com.android.chrome',
            startCommand:              'shell am start -n com.android.chrome/com.google.android.apps.chrome.Main {ifURL} --activity-clear-task',
            doClear:                   true,
            resetWelcomeShellCommands: [
                //new android uses this technique
                'shell am set-debug-app --persistent com.android.chrome',
                //old android uses this technique
                'shell "echo \'chrome --disable-fre --no-default-browser-check --no-first-run\' > /data/local/tmp/chrome-command-line"'
            ],
        },
        firefox: {
            name:                      'firefox',
            packageName:               'org.mozilla.firefox',
            startCommand:              'shell am start -a android.activity.MAIN -n org.mozilla.firefox/org.mozilla.gecko.BrowserApp {ifURL} --ez private_tab true',
            doClear:                   false, // nothing to do since we use the private mode.
            resetWelcomeShellCommands: [
                // nothing to do since we use the private mode.
            ],
        }
    },

    /** 
     * @typedef {Object} OpenBrowserInfoItem
     * @property {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     * @property {BrowserDefinition} browser information on how to handle this browser.
     * @property {string} deviceId deviceId used by adb
     * @property {string} alias The alias known to the user
    */

    /** Maps TestCafes id to an OpenBrowserInfoItem
     * 
     * @type {Object<string, OpenBrowserInfoItem>}
     */
    _openBrowserInfos: {},

    /** Browsers/Devices available through this plugin.
     * 
     * The format is: `${model}:${deviceId}:${browser.name}` or `${model}:${deviceHostname}:${port}:${browser.name}`
     * i.e. `SM-T580:33001f47b4d9b5f1:firefox`
     *
     * @type {string[]}
     */
    _browserList: [],

    /** Runs the specified browser and opens the specified page in it.
     * 
     * required by TestCafe
     * 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     * The identifier is included to the window title exposed using the `document.title` property.
     * @param {string} url The url of the page to open.
     * @param {string} browserName The browser name.
     */
    async openBrowser (id, url, browserName) {
        debug.log(`[android] openBrowser(id='${id}', url='${url}', browserName='${browserName}')`);
        
        if (!browserName) 
            throw new Error('browserName must be specified!');
        
        let browserNameChunks = browserName.split(':');

        // case tcpip - thie deviceId = ${deviceHostname}:${port}
        if (browserNameChunks.length === 4) browserNameChunks = [browserNameChunks[0], browserNameChunks[1] + ':' + browserNameChunks[2], browserNameChunks[3]];

        const deviceId = browserNameChunks[1];
        const browser = browserNameChunks[2];

        /** @type {OpenBrowserInfoItem} */
        const browserInfo = {
            id,
            deviceId,
            browser: this._browserDefinitions[browser],
            alias:   browserName,
        };

        this._openBrowserInfos[id] = browserInfo;

        await this._kill(id);

        // Reset the browser to a fresh installed state
        if (browserInfo.browser.doClear)
            await this._adbExec(id, `shell pm clear ${browserInfo.browser.packageName}`);
        
        // Make sure the browser does not display any first start dialogs.
        for (const shellCommand of browserInfo.browser.resetWelcomeShellCommands)
            await this._adbExec(id, shellCommand);
        
        const needsUrlInsert =  url && url.length > 0;
        const ifURL = needsUrlInsert ? `-d '${url}'` : '';
        const command = browserInfo.browser.startCommand.replace('{ifURL}', ifURL);

        await this._adbExec(id, command);
    },

    /** Closes the specified browser. 
     * 
     * required by TestCafe
     * 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     */
    async closeBrowser (id) {
        debug.log(`[android] closeBrowser(id='${id}(${this._openBrowserInfos[id].alias})')`);
        await this._kill(id);     
    },

    /** Performs initialization actions the provider may require.
     * This method is called once before other provider methods are called.
     * 
     * For example, the Nightmare browser provider uses this method to create a Nightmare instance.
     * 
     * optional for TestCafe
     * 
     * This implementation creates the browser list here.
     */
    async init () {
        debug.log('[android] init()');

        const devices = [];

        debug.log('[android] ---- Device/Browser List ----');

        let deviceLines = await this._shellExec('adb devices');

        deviceLines = deviceLines.slice(1); // remove the first line `List of devices attached`
        
        for (const deviceLine of deviceLines) {
            const deviceId = deviceLine.split(/(\t+)/)[0];  
            
            if (deviceId.length === 0) continue; // not a device
            debug.log('[android] found device: ' + deviceId);
            const deviceModel = (await this._shellExec(`adb -s ${deviceId} shell getprop ro.product.vendor.model`))[0];

            debug.log('[android] found device model: ' + deviceModel);

            for (const browser of Object.values(this._browserDefinitions)) {
                debug.log('[android] checking for browser: ' + browser.packageName);
            
                const packageListLines = await this._shellExec(`adb -s ${deviceId} shell pm list package ${browser.packageName}`);
                
                if (packageListLines[0] !== `package:${browser.packageName}`) {
                    debug.log('[android] browser ' + browser.packageName + ' doesnt appear to be installed');   
                    continue; // package not installed
                }
                
                const alias = `${deviceModel}:${deviceId}:${browser.name}`;

                devices.push(alias);

                debug.log('[android] ' + alias);
            }
        }
        
        if (devices.length === 0) 
            throw new Error('No devices returned from adb. Check your simulators and device connectivity using adb. Check your adb devices command.');
        
        this._browserList = devices;
    },

    // /** Performs cleanup actions for the provider data.
    //  * This method is called before the testcafe process is finished.
    //  *
    //  * optional for TestCafe
    //  */
    // async dispose () {
    //     return;
    // },

    /** Returns the array of names used to identify the browsers.
     * 
     * This method is used if the provider supports multiple browsers.
     * 
     * optional for TestCafe
     * 
     * @returns {string[]}
     */
    async getBrowserList () {
        debug.log('[android] getBrowserList()');
        return this._browserList;
    },

    /** Checks if the specified browser name exists.
     * 
     * This method is used if the provider supports multiple browsers.
     * 
     * optional for TestCafe
     * 
     * @param {string} browserName The browser name to validate.
     * @returns {boolean} true if the specified name exists, or false otherwise.
     */
    async isValidBrowserName (browserName) {
        debug.log(`[android] isValidBrowserName(browserName='${browserName}')`);
        const found = this._browserList.includes(browserName);
        
        if (!found)
            debug.log(`[android] Browser '${browserName}' not found, try one of these: ${JSON.stringify(this._browserList)}`);
        
        return found;
    },
    
    // /** Resizes the browser window's client area to the specified width and height.
    //  * 
    //  * optional extra for TestCafe
    //  * 
    //  * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
    //  * @param {number} width The width to resize the browser window's client area to, in pixels.
    //  * @param {number} height The height to resize the browser window's client area to, in pixels.
    //  * @param {number} currentWidth The actual width of the browser window's client area, in pixels.
    //  * For example, you can use this parameter to calculate the current width of the browser's utility area
    //  * that contains menus, toolbars, etc. This can be useful when you need to resize the whole browser window.
    //  * @param {number} currentHeight The actual height of the browser window's client area, in pixels.
    //  * For example, you can use this parameter to calculate the current height of the browser's utility area
    //  * that contains menus, toolbars, etc. This can be useful when you need to resize the whole browser window.
    //  */
    // async resizeWindow (id, width, height, currentWidth, currentHeight) {
    //     this.reportWarning('The window resize functionality is not supported by the "android" browser provider.');
    // },

    // /** Checks if the browser window can be resized to the specified dimensions.
    //  * 
    //  * optional extra for TestCafe
    //  * 
    //  * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
    //  * @param {number} width The desired width of the browser window's client area, in pixels.
    //  * @param {number} height The desired height of the browser window's client area, in pixels.
    //  * 
    //  * @returns {boolean} true if the window can be resized to the specified width and height, or false otherwise.
    //  */
    // async canResizeWindowToDimensions (id, width, height) {
    //     return true;
    // }

    /** Takes a screenshot of the browser window's client area.
     * 
     * optional extra for TestCafe
     * 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     * @param {string} screenshotPath The directory path to save the screenshots to.
     * @param {number} pageWidth The actual width of the web page opened in the browser, in pixels.
     * @param {number} pageHeight The actual height of the web page opened in the browser, in pixels.
     */
    async takeScreenshot (id, screenshotPath/*, pageWidth, pageHeight*/) {
        debug.log(`[android] takeScreenshot(id='${id}(${this._openBrowserInfos[id].alias})', screenshotPath='${screenshotPath}')`);

        await this._adbExec(id, 'shell screencap /sdcard/screen.png');
        await this._adbExec(id, 'pull /sdcard/screen.png');
        
        await copyFile('screen.png', screenshotPath);
        await unlink('screen.png');
    },

    // /** Maximizes the browser window.
    //  * 
    //  * optional extra for TestCafe
    //  * 
    //  * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
    //  */
    // async maximizeWindow (id){
    //     this.reportWarning('The window maximization functionality is not supported by the "android" browser provider.');
    // }

    /** Executes a shell command and returns the output as an array of strings.
     * 
     * @param {string} command the shell command to be executed
     * @returns {string[]} The resulting shell output.
     */
    async _shellExec (command) {
        const { stdout } = await exec(command);
        const lines = stdout.split(/\r?\n/); // split at line break
        
        // debug.log(`[android] _shellExec(command='${command}') => ${JSON.stringify(lines)}`); 
        return lines;
    },

    /** Executes an adb command.
     * 
     * Takes care of the correct deviceId
     * 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     * @param {string} command the adb command to be executed
     * @returns {string[]} The resulting shell output.
     */
    async _adbExec (id, command) {
        const browserInfo = this._openBrowserInfos[id];

        return await this._shellExec(`adb -s ${browserInfo.deviceId} ${command}`);
    },

    /** 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     * @param {string} keyId
     */
    async keyPress (id, keyId) {
        debug.log(`[android] keyPress(id='${id}(${this._openBrowserInfos[id].alias})', keyId='${keyId}')`);

        await this._adbExec(id, `shell input keyevent ${keyId}`);
    },

    /** Stops a browsers process.
     * 
     * @param {string} id A unique identifier generated by TestCafe that you can use to identify a browser window.
     */
    async _kill (id) {
        const browserInfo = this._openBrowserInfos[id];

        await this._adbExec(id, `shell am force-stop ${browserInfo.browser.packageName}`);
    },
};
